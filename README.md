# Slots — iGaming Slot (Backend + Frontend)

Reference implementation of a slot game:
- backend: RNG, spin engine, JWT-protected API
- frontend: React + PixiJS reel rendering and game UI
- docs: architecture, security, UI and design guides

## Repository Structure

- `backend/` — Node.js + Express API
- `frontend/` — Vite + React + TypeScript + PixiJS client
- `docs/` — architecture and compliance documentation
- `postman/` — API collection and environment

## Requirements

- Node.js 20+
- npm 10+
- PostgreSQL 16+ (local dev; Docker Compose provides it automatically)

## Safe PR Workflow

Use the guard script before creating PRs:

```bash
scripts/safe-pr.sh
```

What it checks:
- not on `main`/`master`
- no merge/rebase/cherry-pick in progress
- clean tracked working tree
- optional untracked-file guard
- commits exist ahead of `origin/main`
- prints exact commits/files that will be in PR

Common usage:

```bash
# local checks only
scripts/safe-pr.sh --allow-untracked

# check + push + open PR
scripts/safe-pr.sh --allow-untracked --push --create-pr --title "Your PR title"
```

## Quick Start (Development)

The fastest way — one command starts postgres, backend, and frontend:

```bash
scripts/dev.sh
```

The script starts a Docker postgres container if postgres isn't already reachable,
loads `backend/.env.development`, then runs both servers with labelled output.
Press **Ctrl+C** to shut everything down.

### Manual setup (step by step)

1. Start a local PostgreSQL instance (Docker is the easiest):

```bash
docker run -d --name slotsone-pg \
  -e POSTGRES_DB=slotsone \
  -e POSTGRES_USER=slotsone \
  -e POSTGRES_PASSWORD=slotsone \
  -p 5432:5432 \
  postgres:16-alpine
```

2. Start backend:

```bash
cd backend
npm install
cp .env.development.example .env.development
# add to .env.development:
# DATABASE_URL=postgres://slotsone:slotsone@localhost:5432/slotsone
npm run dev
```

Backend runs on `http://localhost:3001`.
Tables are created automatically on first start (`CREATE TABLE IF NOT EXISTS`).
Interactive Swagger docs: `http://localhost:3001/api-docs` (spec: `/api-docs.json`).

API contract source of truth:
- `backend/src/docs/openapi.ts` (served directly as `/api-docs.json`)
- `backend/src/contracts/gameContract.ts` (runtime validation + schema definitions)
- `backend/src/tests/apiContract.test.ts` (guards request/response compatibility)

Contract-generated artifacts:
- `backend/openapi.json` (generated by `backend` script)
- `frontend/src/generated/openapi.ts` (generated TS types from OpenAPI)

Sync commands:

```bash
cd backend && npm run openapi:generate
cd ../frontend && npm run api:types:generate
```

3. Start frontend in a second terminal:

```bash
cd frontend
npm install
npm run dev
```

Open `http://localhost:5173`. Vite proxies `/api` to the backend.

## Quick Start (Docker Compose)

1. Create docker env file:

```bash
cp .env.docker.example .env.docker
```

2. Set `JWT_PUBLIC_KEY` (and optional values) in `.env.docker`.

3. Start all services (backend, frontend, **and postgres**):

```bash
docker compose --env-file .env.docker up -d --build
```

PostgreSQL starts first; backend waits for the healthcheck before accepting connections.
Tables are created automatically on backend startup.

App URL: `http://localhost:8080`
Backend health: `http://localhost:3001/health`

## API Endpoints

- `POST /api/v1/game/init`
- `POST /api/v1/spin`
- `GET /api/v1/history`
- `GET /health`
- `GET /api-docs` (Swagger UI)
- `GET /api-docs.json` (OpenAPI spec)

## Authentication (JWT)

The backend accepts only valid JWT tokens in:

`Authorization: Bearer <token>`

Supported signing algorithms:
- `RS256`

Configuration is loaded automatically from:
- `backend/.env`
- `backend/.env.<NODE_ENV>`

### Important JWT Environment Variables

- `JWT_ALLOWED_ALGS` — set to `RS256`
- `JWT_PUBLIC_KEY` — required in all environments (PEM; supports `\n`)
- `JWT_ISSUER` — optional claim check
- `JWT_AUDIENCE` — optional claim check

### Database Environment Variable

- `DATABASE_URL` — required; PostgreSQL connection string.
  Format: `postgres://<user>:<password>@<host>:<port>/<dbname>`
  Example: `postgres://slotsone:slotsone@localhost:5432/slotsone`

Schema migrations run automatically at startup (`CREATE TABLE IF NOT EXISTS`), so no manual migration step is needed.

### CORS Environment Variable

- `CORS_ORIGINS` — comma-separated allowlist for browser clients (for example `https://app.example.com,https://admin.example.com`).
  Use `*` only for local/dev use cases.

### Dev Key Setup (RS256)

Generate a local key pair:

```bash
openssl genrsa -out backend/jwt_private.pem 2048
openssl rsa -in backend/jwt_private.pem -pubout -out backend/jwt_public.pem
```

Create `backend/.env.development` using `backend/.env.development.example`, then set:

```bash
JWT_ALLOWED_ALGS=RS256
JWT_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----"
JWT_ISSUER=slotsone-dev
JWT_AUDIENCE=slotsone-client
DATABASE_URL=postgres://slotsone:slotsone@localhost:5432/slotsone
```

For Postman testing, obtain a token via `POST /api/v1/auth/login` and use it as `jwt_token` in `postman/dev.env.json`.

## Production Deployment (GitHub Actions + Docker Compose)

This repository includes:
- `docker-compose.prod.yml`
- `backend/Dockerfile`
- `frontend/Dockerfile`
- `.github/workflows/deploy.yml`
- `ops/server/bootstrap_deploy_user.sh`

### 1) Prepare the server (run once as root)

```bash
git clone <your-repo-url>
cd slotsone
sudo DEPLOY_USER=deploy DEPLOY_PUBLIC_KEY="<your-public-key>" bash ops/server/bootstrap_deploy_user.sh
```

After script execution:
- Docker + Compose plugin are installed
- non-root `deploy` user exists
- `/opt/slotsone` is owned by `deploy`

### 2) Configure runtime env files on the server

Login as `deploy` and create:
- `/opt/slotsone/backend/.env.production` (backend config)
- `/opt/slotsone/.env.production` (root file used for compose build args)

You can start from:
- `backend/.env.production.example`
- `.env.production.example`

`backend/.env.production` must include:

```bash
DATABASE_URL=postgres://<POSTGRES_USER>:<POSTGRES_PASSWORD>@postgres:5432/<POSTGRES_DB>
POSTGRES_USER=<your-db-user>
POSTGRES_PASSWORD=<your-db-password>
POSTGRES_DB=<your-db-name>
```

Example root `.env.production`:

```bash
VITE_SYMBOL_ASSET_VERSION=ai-symbols-v2
TLS_DOMAIN=<your-domain.example.com>
ACME_EMAIL=<ops-email@example.com>
POSTGRES_USER=slotsone
POSTGRES_PASSWORD=<strong-password>
POSTGRES_DB=slotsone
```

### 3) Add GitHub repository secrets

Required secrets for `.github/workflows/deploy.yml`:
- `DEPLOY_HOST` (for example `64.176.72.28`)
- `DEPLOY_PORT` (usually `22`)
- `DEPLOY_USER` (for example `deploy`)
- `DEPLOY_PATH` (for example `/opt/slotsone`)
- `DEPLOY_SSH_KEY_B64` (base64-encoded private key for SSH)
- `DEPLOY_KNOWN_HOSTS` (optional but recommended)
- `POSTGRES_USER` — database username
- `POSTGRES_PASSWORD` — database password
- `POSTGRES_DB` — database name

### 4) Deploy

- Push to `main` (or run workflow manually via `workflow_dispatch`)
- GitHub Actions builds backend/frontend
- Workflow syncs files over SSH and runs:

```bash
docker compose --env-file .env.production -f docker-compose.prod.yml up -d --build --remove-orphans
```

App is served by frontend nginx container on port `80` and proxies `/api` to backend.

### SSL (Let's Encrypt via Caddy)

Production compose now includes a Caddy reverse proxy with automatic TLS.

Requirements:
1. Point your DNS A record to the server IP.
2. Ensure inbound ports `80` and `443` are open.
3. Set these values in `/opt/slotsone/.env.production`:

```bash
TLS_DOMAIN=<your-domain.example.com>
ACME_EMAIL=<ops-email@example.com>
```

After deploy, Caddy requests and renews certificates automatically.

## Manual Build Commands

```bash
# Backend
cd backend
npm run build
npm start

# Frontend
cd frontend
npm run build
```

## Custom Slot Symbols (Images)

The frontend now supports symbol images from `frontend/public/symbols`.

Expected file names:
- `10.png`
- `j.png`
- `q.png`
- `k.png`
- `a.png`
- `star.png`
- `scatter.png`
- `wild.png`

If any file is missing, the reel renderer automatically falls back to the built-in vector symbol.

Generate a full symbol set with OpenAI Images API:

```bash
OPENAI_API_KEY=<your_key> node scripts/generate-slot-symbols.mjs
```

Optional model override:

```bash
OPENAI_API_KEY=<your_key> OPENAI_IMAGE_MODEL=gpt-image-1 node scripts/generate-slot-symbols.mjs
```

## Lint & Format

```bash
cd backend && npm run lint && npm run format:check
cd ../frontend && npm run lint && npm run format:check
```

### Pre-commit Hook (lint-staged)

Running `npm install` in either `frontend/` or `backend/` automatically
configures Git to use `.githooks/` as the hooks directory. A `pre-commit`
hook runs `lint-staged`, which auto-fixes ESLint and Prettier issues on
staged files before every commit.

To set up hooks manually:

```bash
git config core.hooksPath .githooks
```

## Testing (Postman/Newman)

```bash
cd postman
newman run slots-collection.json -e dev.env.json
```

See `postman/README.md` for the full regression suite details.

## Frontend E2E Tests (Playwright)

```bash
cd frontend
npx playwright install chromium
npm run test:e2e
```

The suite mocks `/api/v1/game/init` and `/api/v1/spin` to validate UI flow deterministically:
- CV landing is visible
- Slots screen opens
- SPIN triggers a request and displays WIN feedback

## Game Flow Summary

1. Client calls `POST /api/v1/game/init`
2. User presses **SPIN**
3. Client calls `POST /api/v1/spin` with `session_id`, `bet`, optional `Idempotency-Key`
4. Backend returns authoritative outcome (`reel_matrix`, `win`, `bonus_triggered`)
5. Frontend animates reels and displays win/bonus states
