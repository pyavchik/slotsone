# UI/UX архитектура онлайн-слота (iGaming)

Полный стек, игровой цикл, компоненты и меры защиты на клиенте.

---

## 1. ТЕХНОЛОГИИ

### 1.1 Рендеринг барабанов (WebGL)

**PixiJS** — основной выбор для 2D-слотов:

- WebGL (с fallback на Canvas) из коробки.
- Спрайты символов как `Texture` из атласов (PNG/JSON).
- Отдельный `Container` на каждый барабан (reel), внутри — полоса символов с маской видимой области (5×3 → видно 3 ряда).
- Анимация: изменение `y` или обновление позиций символов в цикле (ticker), затем «привязка» к финальным позициям из outcome.
- ParticleContainer для лампочек, частиц без логики коллизий.

**Three.js** — для 3D-слотов:

- Каждый барабан — группа `Mesh` (символы как плоскости с текстурами или 3D-модели).
- Вращение вокруг оси (reel rotation), остановка по углам, соответствующим outcome.
- Камера, освещение, постобработка (bloom для «Big Win»).

**Рекомендация**: для классического 5×3 чаще используют **PixiJS** (проще, легче, быстрее для 2D). Three.js — при необходимости 3D-рельсов и кинематики.

---

### 1.2 Оболочка (HUD): React или Vue

- **React** (или **Vue 3**) — всё, что не WebGL: баланс, ставка, кнопки, модалки, маршрутизация.
- Состояние: глобальный store (Zustand, Pinia, Redux) — баланс, ставка, автоспин, блокировка UI во время спина, результат последнего спина (для линий и оверлеев).
- WebGL-холст (Pixi/Three) монтируется в один ref (React) или через `vue-pixi` / кастомный wrapper: создание `Application` в `useEffect`/`onMounted`, передача колбэков (onSpinClick) и данных (outcome) в контейнер с канвасом.

**Связка React + PixiJS**:

- Один корневой компонент владеет `PixiApplication` (ref).
- ReelGrid — либо отдельный класс/модуль внутри этого ref, либо компонент, получающий `app` через context.
- События: «SPIN нажат» → store/spin request → по ответу API передаём outcome в ReelGrid и запускаем анимацию.

---

### 1.3 WebSocket клиент

- Подключение к `wss://api.example.com/ws/game?token=<JWT>` при входе в игру.
- Подписка на каналы: `balance`, `game_events` (опционально).
- При `balance_updated` — обновление баланса в store и в HUD без перезагрузки.
- Reconnect с exponential backoff, повторная аутентификация по JWT.
- Спины идут через **REST** (POST /spin), WebSocket — только для live-обновлений (баланс, уведомления), не для подмены результата спина.

---

## 2. ИГРОВОЙ ЦИКЛ (Game Loop)

Последовательность шагов от нажатия SPIN до обновления баланса.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. User clicks SPIN                                                         │
│     → UI: disable SPIN, show "spinning" state                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. Client: POST /api/v1/spin                                               │
│     Body: { session_id, game_id, bet: { amount, currency, lines } }          │
│     Headers: Authorization: Bearer <session_token>                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. Server: validates, runs RNG, calculates outcome, saves to DB             │
│     Response: { spin_id, balance, outcome: { reel_matrix, win, bonus } }     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  4. Client: receives outcome (authoritative)                                │
│     → Store: set balance from response; set outcome for ReelGrid             │
│     → ReelGrid: start reel animation (spinning)                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  5. Reel animation: each reel stops in sequence (e.g. left to right)        │
│     Final positions MUST match outcome.reel_matrix (no client randomness)   │
│     → Play stop sound per reel; optional anticipation on last reels          │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  6. After all reels stopped:                                                │
│     → Paylines: highlight winning lines (from outcome.win.breakdown)        │
│     → Effects: particles, flash, sound for win amount                       │
│     → If win > threshold: "Big Win" overlay animation                       │
│     → If bonus_triggered: BonusOverlay (Free Spins count, etc.)             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  7. Balance already updated from step 3; HUD shows new balance               │
│     → Re-enable SPIN (or trigger next AutoSpin after delay)                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Важно**:

- Результат спина **всегда** приходит с сервера. Клиент не вычисляет и не подменяет outcome — только анимирует переданный `reel_matrix` и отображает `win` / бонусы.
- Блокировка кнопки SPIN на время запроса и анимации предотвращает двойные запросы и рассинхрон.

---

## 3. КОМПОНЕНТЫ UI

### 3.1 ReelGrid (5×3 сетка, анимация барабанов)

**Назначение**: отображение символов и анимация «вращения» с остановкой по серверному outcome.

**Структура (PixiJS)**:

- 5 контейнеров (reels). В каждом — вертикальная полоса символов (strip): для плавного скролла храним больше 3 символов (например 5–7), видимая область обрезана маской (3 символа).
- Символы — спрайты из атласа, ключ по `symbol_id` из конфига.

**Анимация**:

1. **Spinning**: в цикле (ticker) сдвигаем strip вниз (или вверх), при выходе символа за край — переставляем его в противоположный конец и подставляем «случайный» символ из визуального набора (только для вида, не для результата).
2. **Stop**: по таймеру или по очереди (reel 0 → reel 1 → … → reel 4) останавливаем барабан так, чтобы в видимой зоне оказались **ровно** символы из `outcome.reel_matrix[column]`. Позиции финальные задаются сервером — подгоняем scroll offset так, чтобы визуально совпало.
3. Easing (easeOutQuad / easeOutCubic) на последних пикселях для «мягкой» остановки.

**Props/Input**:

- `outcome: { reel_matrix: string[][] }` — после ответа API.
- `onReelStopped?: (reelIndex: number) => void` — для звука/эффектов по каждому барабану.
- `onAllReelsStopped?: () => void` — для показа линий и оверлеев.

**Состояния**: idle, spinning, stopping.

---

### 3.2 Paylines (выигрышные линии)

**Назначение**: подсветка линий, по которым прошла выигрышная комбинация.

**Реализация**:

- Линии заданы в конфиге: массив путей `[ [reel, row], ... ]` для каждой линии (например 20 линий для 5×3).
- По `outcome.win.breakdown` знаем, какие `line_index` выиграли и какие символы.
- Рисуем поверх ReelGrid:
  - **PixiJS**: Graphics — линии (curve или segment) по координатам слотов, цвет/свечение для выигрышной линии.
  - Или отдельный слой с пререндеренными спрайтами линий (вкл/выкл по индексу).
- Анимация: короткая вспышка/glow при `onAllReelsStopped`, затем таймер отключения или переход к следующему шагу (Big Win overlay).

**Данные**: `winningLineIndices: number[]`, `paylinePaths: [reel, row][][]` из конфига.

---

### 3.3 BetPanel (ставка)

**Элементы**:

- Текущая ставка (монеты/валюта).
- Кнопки **- / +** или список уровней ставки (например 0.10, 0.20, … 100).
- Отображение **min / max** (из конфига игры после init).
- Валюта (из баланса/сессии).

**Поведение**:

- Ставка хранится в store; при изменении — валидация против min/max.
- Во время спина и анимации панель ставки обычно **disabled**, чтобы нельзя было изменить bet до завершения цикла.
- Отправка в POST /spin: `bet: { amount: currentBet, currency, lines }`.

---

### 3.4 AutoSpin

**Настройки** (в модалке или панели):

- Количество спинов: 10, 25, 50, 100, «до отмены».
- Условия остановки: «остановить при выигрыше &gt; X», «остановить при бонусе», «без ограничений».
- Кнопка **Start AutoSpin** / **Stop AutoSpin**.

**Логика**:

- После завершения одного спина (все барабаны остановились, эффекты показаны) — таймер (например 1–2 сек), затем автоматический вызов того же flow: POST /spin с текущей ставкой. Счётчик автоспинов уменьшается.
- Остановка при: срабатывании условия, нажатии Stop, недостатке баланса, открытии бонус-раунда (опционально — пауза автоспина до конца бонуса).

**UI**: индикатор «AutoSpin 47/100» и кнопка Stop.

---

### 3.5 InfoPanel (paytable, правила)

- **Кнопка (i) или «Paytable»** открывает модальное окно.
- Контент: таблица выплат (символ × количество = множитель), описание бонусов (Scatter, Free Spins, множители), ссылка на полные правила (внешняя страница или встроенный iframe/HTML из конфига).
- Данные могут подгружаться с CDN (config.paytable_url) или быть в конфиге после init.

---

### 3.6 BonusOverlay

**Сценарии**:

- **Триггер бонуса** (например 3+ Scatter): полноэкранный оверлей «FREE SPINS x10», анимация счёта спинов, кнопка «Start» или автоматический переход к первому бонус-спину.
- **Во время Free Spins**: счётчик «7 / 10», множитель «x2», при необходимости — кнопка «Skip» (если продукт разрешает).
- **Big Win**: при выигрыше выше порога — оверлей «BIG WIN» с суммой и конфетти/анимация, затем закрытие и продолжение.

**Реализация**: React/Vue компоненты поверх канваса (z-index), анимации через CSS/GSAP или Lottie. Данные (количество спинов, множитель, сумма) приходят с сервера в outcome и хранятся в store.

---

## 4. ANTI-CHEAT НА КЛИЕНТЕ

Цель: усложнить манипуляции через DevTools и подмену кода, не создавая иллюзию «полной защиты» (критичная логика и баланс — только на сервере).

### 4.1 Предотвращение манипуляции с результатами

- **Outcome только с сервера**: клиент никогда не генерирует и не перезаписывает результат спина. ReelGrid получает `reel_matrix` и `win` из ответа API и только отображает их. Даже если пользователь изменит переменную в консоли, следующий спин снова придет с сервера и перезапишет состояние.
- **Не хранить баланс только на клиенте**: баланс приходит с каждым ответом /spin и при WebSocket; UI показывает серверное значение. Проверка «хватает ли на ставку» дублируется на сервере (422 при недостатке средств).
- **Токен и запросы**: JWT в httpOnly cookie (где возможно) или в памяти; не класть долгоживущий токен в localStorage с открытым доступом из консоли. Критичные действия (спин, вывод) только с валидным токеном и rate limit на сервере.
- **Целостность ответа**: проверять наличие обязательных полей (`spin_id`, `outcome.reel_matrix`, `balance`). При неполном ответе не запускать анимацию выигрыша, показывать ошибку и при необходимости переподключаться.

### 4.2 Obfuscation JS

- **Минификация + обфускация** (например Webpack + Terser + обфускатор вроде javascript-obfuscator): имена переменных/функций, строки, контрольный поток (flatten), разбиение строк. Цель — усложнить чтение и точечное изменение логики (например подмена функции, парсящей outcome).
- **Не полагаться только на обфускацию**: сервер остаётся источником правды; обфускация лишь повышает порог для быстрого хака.

### 4.3 Fingerprinting сессии

- **Зачем**: привязка сессии к устройству/браузеру для выявления мультиаккаунтов, подозрительной смены контекста, частично — детект ботов.
- **Данные** (собираются на клиенте и отправляются при init или первом spin):
  - User-Agent, язык, часовой пояс, разрешение экрана, глубина цвета.
  - Canvas fingerprint (рисование текста/фигур и хэш пикселей).
  - WebGL renderer/vendor (если не скрыто).
  - Список плагинов/шрифтов (где доступно).
- **Отправка**: хэш fingerprint в заголовке (например `X-Client-Fingerprint: <hash>`) или в теле запроса. Сервер сохраняет привязку session_id ↔ fingerprint и при смене может требовать повторную аутентификацию или логировать для антифрода.
- **Ограничения**: не блокировать игру только по смене fingerprint (VPN, очистка кэша), использовать как сигнал в совокупности с другими признаками.

### 4.4 Дополнительно

- **Детект DevTools**: проверка `window.outerWidth - window.innerWidth` или `debugger` в коде (легко обходится, но может замедлить неопытного пользователя). Не блокировать игру жёстко — только опциональное логирование на бэкенд.
- **Тайминги**: сервер может проверять разумные интервалы между спинами (не 0 мс); клиент не должен отправлять следующий spin до получения ответа предыдущего.
- **Rate limiting**: лимиты на /spin на сервере по user_id/session_id, чтобы исключить флуд и автоматизированные запросы.

---

## Сводка по стеку

| Слой            | Технология              | Назначение                          |
|-----------------|-------------------------|-------------------------------------|
| Рендер барабанов| PixiJS (2D) / Three.js (3D) | ReelGrid, символы, анимация     |
| Оболочка        | React или Vue           | HUD, BetPanel, AutoSpin, модалки     |
| Сеть            | REST (fetch/axios) + WebSocket | Спины, init, live-обновления   |
| Состояние       | Zustand / Pinia / Redux | Баланс, ставка, outcome, автоспин   |
| Анимация UI     | CSS / GSAP / Lottie     | Оверлеи, кнопки, Big Win            |

Игровой цикл строится вокруг **серверного outcome**: клиент только отображает и анимирует уже выданный результат; античит на клиенте дополняет серверную валидацию и усложняет примитивные манипуляции.
